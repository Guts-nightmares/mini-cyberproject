#!/usr/bin/env python3
"""
Report Generator - Generation de rapports professionnels pour pentest

Ce script permet de:
- Creer des rapports structures pour clients
- Gerer des findings de vulnerabilites
- Generer des rapports en Markdown et HTML
- Inclure des preuves de concept
- Fournir des recommandations de remediation

Usage:
    python report-generator.py --init "Client-2024-001"
    python report-generator.py --add-finding --title "SQL Injection" --severity critical
    python report-generator.py --generate --format html
"""

import argparse
import json
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, List


class ReportGenerator:
    """Generateur de rapports professionnels pour pentest"""

    SEVERITIES = {
        'critical': {'score': 4, 'color': 'red', 'cvss_range': '9.0-10.0'},
        'high': {'score': 3, 'color': 'orange', 'cvss_range': '7.0-8.9'},
        'medium': {'score': 2, 'color': 'yellow', 'cvss_range': '4.0-6.9'},
        'low': {'score': 1, 'color': 'blue', 'cvss_range': '0.1-3.9'},
        'info': {'score': 0, 'color': 'green', 'cvss_range': '0.0'}
    }

    def __init__(self, reports_dir: str = "reports"):
        self.base_dir = Path(reports_dir)
        self.base_dir.mkdir(exist_ok=True)
        self.current_report: str = None
        self.load_current_report()

    def load_current_report(self) -> None:
        """Charge le rapport actif"""
        state_file = self.base_dir / "current.txt"
        if state_file.exists():
            self.current_report = state_file.read_text().strip()

    def init_report(self, name: str, client: str = "", tester: str = "",
                    scope: str = "", methodology: str = "OWASP") -> None:
        """Initialise un nouveau rapport"""
        report_id = name
        report_dir = self.base_dir / report_id
        report_dir.mkdir(exist_ok=True)

        metadata = {
            "report_id": report_id,
            "client_name": client,
            "tester_name": tester,
            "scope": scope,
            "methodology": methodology,
            "created_date": datetime.now().isoformat(),
            "findings": [],
            "status": "draft"
        }

        metadata_file = report_dir / "report.json"
        with open(metadata_file, 'w') as f:
            json.dump(metadata, f, indent=2)

        self.current_report = report_id
        state_file = self.base_dir / "current.txt"
        state_file.write_text(report_id)

        print(f"[+] Rapport '{report_id}' initialise")
        print(f"[+] Repertoire: {report_dir}")

    def add_finding(self, title: str, severity: str, description: str = "",
                    impact: str = "", remediation: str = "", cvss: str = "",
                    affected_systems: List[str] = None, poc: str = "",
                    references: List[str] = None) -> None:
        """Ajoute une vulnerabilite au rapport"""
        if not self.current_report:
            print("[!] Aucun rapport actif. Utilisez --init d'abord")
            sys.exit(1)

        if severity.lower() not in self.SEVERITIES:
            print(f"[!] Severite invalide. Utilisez: {', '.join(self.SEVERITIES.keys())}")
            sys.exit(1)

        report_dir = self.base_dir / self.current_report
        metadata_file = report_dir / "report.json"

        with open(metadata_file, 'r') as f:
            metadata = json.load(f)

        finding_id = f"FINDING-{len(metadata['findings']) + 1:03d}"

        finding = {
            "id": finding_id,
            "title": title,
            "severity": severity.lower(),
            "cvss_score": cvss,
            "description": description,
            "impact": impact,
            "affected_systems": affected_systems or [],
            "proof_of_concept": poc,
            "remediation": remediation,
            "references": references or [],
            "discovered_date": datetime.now().isoformat(),
            "status": "open"
        }

        metadata['findings'].append(finding)

        with open(metadata_file, 'w') as f:
            json.dump(metadata, f, indent=2)

        print(f"[+] Finding ajoute: {finding_id} - {title} ({severity.upper()})")

    def generate_markdown(self) -> None:
        """Genere un rapport en Markdown"""
        if not self.current_report:
            print("[!] Aucun rapport actif")
            sys.exit(1)

        report_dir = self.base_dir / self.current_report
        metadata_file = report_dir / "report.json"

        with open(metadata_file, 'r') as f:
            metadata = json.load(f)

        output_file = report_dir / "report.md"

        with open(output_file, 'w') as f:
            # En-tete
            f.write(f"# Rapport de Test d'Intrusion\n\n")
            f.write(f"## {metadata.get('client_name', 'Client Confidentiel')}\n\n")

            # Informations generales
            f.write("## Informations Generales\n\n")
            f.write("| Champ | Valeur |\n")
            f.write("|-------|--------|\n")
            f.write(f"| **Rapport ID** | {metadata['report_id']} |\n")
            f.write(f"| **Client** | {metadata.get('client_name', 'N/A')} |\n")
            f.write(f"| **Testeur** | {metadata.get('tester_name', 'N/A')} |\n")
            f.write(f"| **Date** | {datetime.fromisoformat(metadata['created_date']).strftime('%Y-%m-%d')} |\n")
            f.write(f"| **Methodologie** | {metadata.get('methodology', 'N/A')} |\n")
            f.write(f"| **Statut** | {metadata.get('status', 'draft')} |\n\n")

            if metadata.get('scope'):
                f.write(f"**Scope:** {metadata['scope']}\n\n")

            # Resume executif
            f.write("## Resume Executif\n\n")
            findings = metadata['findings']
            f.write(f"Ce rapport presente les resultats du test d'intrusion ")
            f.write(f"realise pour {metadata.get('client_name', 'le client')}. ")
            f.write(f"Au total, **{len(findings)} vulnerabilites** ont ete identifiees.\n\n")

            # Statistiques
            f.write("### Repartition par Severite\n\n")
            severity_counts = {}
            for finding in findings:
                sev = finding['severity']
                severity_counts[sev] = severity_counts.get(sev, 0) + 1

            f.write("| Severite | Nombre |\n")
            f.write("|----------|--------|\n")
            for sev in ['critical', 'high', 'medium', 'low', 'info']:
                count = severity_counts.get(sev, 0)
                if count > 0:
                    f.write(f"| **{sev.upper()}** | {count} |\n")

            # Findings detailles
            f.write("\n## Vulnerabilites Identifiees\n\n")

            # Trier par severite
            sorted_findings = sorted(
                findings,
                key=lambda x: self.SEVERITIES[x['severity']]['score'],
                reverse=True
            )

            for idx, finding in enumerate(sorted_findings, 1):
                f.write(f"### {idx}. {finding['title']}\n\n")

                f.write("| Champ | Valeur |\n")
                f.write("|-------|--------|\n")
                f.write(f"| **ID** | {finding['id']} |\n")
                f.write(f"| **Severite** | **{finding['severity'].upper()}** |\n")
                if finding.get('cvss_score'):
                    f.write(f"| **CVSS Score** | {finding['cvss_score']} |\n")
                f.write(f"| **Statut** | {finding.get('status', 'open')} |\n\n")

                if finding.get('description'):
                    f.write(f"**Description:**\n\n{finding['description']}\n\n")

                if finding.get('affected_systems'):
                    f.write(f"**Systemes Affectes:**\n\n")
                    for system in finding['affected_systems']:
                        f.write(f"- {system}\n")
                    f.write("\n")

                if finding.get('impact'):
                    f.write(f"**Impact:**\n\n{finding['impact']}\n\n")

                if finding.get('proof_of_concept'):
                    f.write(f"**Preuve de Concept:**\n\n```\n{finding['proof_of_concept']}\n```\n\n")

                if finding.get('remediation'):
                    f.write(f"**Remediation:**\n\n{finding['remediation']}\n\n")

                if finding.get('references'):
                    f.write(f"**References:**\n\n")
                    for ref in finding['references']:
                        f.write(f"- {ref}\n")
                    f.write("\n")

                f.write("---\n\n")

            # Recommandations
            f.write("## Recommandations Prioritaires\n\n")
            critical_high = [f for f in sorted_findings
                           if f['severity'] in ['critical', 'high']]

            if critical_high:
                f.write("Les vulnerabilites suivantes doivent etre corrigees en priorite:\n\n")
                for finding in critical_high:
                    f.write(f"1. **{finding['title']}** ({finding['severity'].upper()})\n")
                    if finding.get('remediation'):
                        f.write(f"   - {finding['remediation'].split('.')[0]}.\n")
                f.write("\n")
            else:
                f.write("Aucune vulnerabilite critique ou haute n'a ete identifiee.\n\n")

            # Conclusion
            f.write("## Conclusion\n\n")
            f.write("Ce rapport documente les vulnerabilites identifiees pendant le test d'intrusion. ")
            f.write("Il est recommande de traiter les vulnerabilites par ordre de severite.\n\n")

            # Annexes
            f.write("## Annexes\n\n")
            f.write("### Methodologie\n\n")
            f.write(f"Ce test a ete realise en suivant la methodologie {metadata.get('methodology', 'OWASP')}.\n\n")

            f.write("### Glossaire\n\n")
            f.write("- **CVSS**: Common Vulnerability Scoring System\n")
            f.write("- **PoC**: Proof of Concept\n")
            f.write("- **CVE**: Common Vulnerabilities and Exposures\n\n")

            # Disclaimer
            f.write("---\n\n")
            f.write("*Ce rapport est confidentiel et destine uniquement au client mentionne. ")
            f.write("Toute diffusion non autorisee est interdite.*\n")

        print(f"[+] Rapport Markdown genere: {output_file}")

    def generate_html(self) -> None:
        """Genere un rapport en HTML"""
        self.generate_markdown()

        report_dir = self.base_dir / self.current_report
        md_file = report_dir / "report.md"
        html_file = report_dir / "report.html"

        # Lire le Markdown
        with open(md_file, 'r') as f:
            md_content = f.read()

        # Template HTML simple
        html_template = """<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rapport de Test d'Intrusion</title>
    <style>
        body {{
            font-family: Arial, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f4f4f4;
        }}
        .container {{
            background-color: white;
            padding: 30px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }}
        h1 {{
            color: #333;
            border-bottom: 3px solid #007bff;
            padding-bottom: 10px;
        }}
        h2 {{
            color: #007bff;
            margin-top: 30px;
        }}
        h3 {{
            color: #555;
        }}
        table {{
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }}
        th, td {{
            padding: 12px;
            text-align: left;
            border: 1px solid #ddd;
        }}
        th {{
            background-color: #007bff;
            color: white;
        }}
        .critical {{
            color: #d9534f;
            font-weight: bold;
        }}
        .high {{
            color: #f0ad4e;
            font-weight: bold;
        }}
        .medium {{
            color: #5bc0de;
            font-weight: bold;
        }}
        .low {{
            color: #5cb85c;
        }}
        code {{
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
        }}
        pre {{
            background-color: #f4f4f4;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }}
        .footer {{
            margin-top: 50px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            font-size: 0.9em;
            color: #777;
        }}
    </style>
</head>
<body>
    <div class="container">
        <div id="content">
{content}
        </div>
        <div class="footer">
            <p>Rapport genere le {date}</p>
            <p><em>Ce document est confidentiel et destine uniquement au client mentionne.</em></p>
        </div>
    </div>
</body>
</html>"""

        # Conversion Markdown simple vers HTML
        html_content = md_content
        html_content = html_content.replace('# ', '<h1>').replace('\n\n', '</h1>\n\n', 1)
        html_content = html_content.replace('## ', '<h2>').replace('\n\n', '</h2>\n\n')
        html_content = html_content.replace('### ', '<h3>').replace('\n\n', '</h3>\n\n')
        html_content = html_content.replace('**CRITICAL**', '<span class="critical">CRITICAL</span>')
        html_content = html_content.replace('**HIGH**', '<span class="high">HIGH</span>')
        html_content = html_content.replace('**MEDIUM**', '<span class="medium">MEDIUM</span>')
        html_content = html_content.replace('**LOW**', '<span class="low">LOW</span>')
        html_content = html_content.replace('\n', '<br>\n')

        final_html = html_template.format(
            content=html_content,
            date=datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        )

        with open(html_file, 'w') as f:
            f.write(final_html)

        print(f"[+] Rapport HTML genere: {html_file}")

    def list_findings(self) -> None:
        """Liste toutes les vulnerabilites"""
        if not self.current_report:
            print("[!] Aucun rapport actif")
            sys.exit(1)

        report_dir = self.base_dir / self.current_report
        metadata_file = report_dir / "report.json"

        with open(metadata_file, 'r') as f:
            metadata = json.load(f)

        findings = metadata['findings']

        if not findings:
            print("[*] Aucune vulnerabilite trouvee")
            return

        print(f"\n=== FINDINGS - {self.current_report} ===\n")

        sorted_findings = sorted(
            findings,
            key=lambda x: self.SEVERITIES[x['severity']]['score'],
            reverse=True
        )

        for finding in sorted_findings:
            print(f"{finding['id']}: {finding['title']}")
            print(f"  Severite: {finding['severity'].upper()}")
            if finding.get('cvss_score'):
                print(f"  CVSS: {finding['cvss_score']}")
            if finding.get('affected_systems'):
                print(f"  Systemes: {', '.join(finding['affected_systems'][:3])}")
            print()


def main():
    parser = argparse.ArgumentParser(
        description="Generateur de rapports professionnels pour pentest",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Exemples:
  # Initialiser un rapport
  python report-generator.py --init "Client-2024-001" --client "ACME Corp" --tester "John Doe"

  # Ajouter une vulnerabilite
  python report-generator.py --add-finding \\
    --title "SQL Injection in login form" \\
    --severity critical \\
    --cvss "9.1" \\
    --description "The login form is vulnerable to SQL injection" \\
    --impact "Full database compromise possible" \\
    --remediation "Use prepared statements" \\
    --affected "app.example.com"

  # Lister les findings
  python report-generator.py --list-findings

  # Generer le rapport
  python report-generator.py --generate --format markdown
  python report-generator.py --generate --format html

Severites:
  - critical (CVSS 9.0-10.0)
  - high (CVSS 7.0-8.9)
  - medium (CVSS 4.0-6.9)
  - low (CVSS 0.1-3.9)
  - info (CVSS 0.0)
        """
    )

    parser.add_argument('--init', metavar='NAME',
                       help='Initialiser un nouveau rapport')
    parser.add_argument('--client', metavar='NAME',
                       help='Nom du client (avec --init)')
    parser.add_argument('--tester', metavar='NAME',
                       help='Nom du testeur (avec --init)')
    parser.add_argument('--scope', metavar='DESC',
                       help='Description du scope (avec --init)')
    parser.add_argument('--methodology', default='OWASP',
                       help='Methodologie utilisee (default: OWASP)')

    parser.add_argument('--add-finding', action='store_true',
                       help='Ajouter une vulnerabilite')
    parser.add_argument('--title', metavar='TEXT',
                       help='Titre de la vulnerabilite')
    parser.add_argument('--severity', metavar='LEVEL',
                       choices=['critical', 'high', 'medium', 'low', 'info'],
                       help='Severite')
    parser.add_argument('--cvss', metavar='SCORE',
                       help='Score CVSS (ex: 9.1)')
    parser.add_argument('--description', metavar='TEXT', default='',
                       help='Description detaillee')
    parser.add_argument('--impact', metavar='TEXT', default='',
                       help='Impact de la vulnerabilite')
    parser.add_argument('--remediation', metavar='TEXT', default='',
                       help='Recommandations de remediation')
    parser.add_argument('--affected', metavar='SYSTEM', action='append',
                       help='Systeme affecte (peut etre utilise plusieurs fois)')
    parser.add_argument('--poc', metavar='TEXT', default='',
                       help='Preuve de concept')
    parser.add_argument('--reference', metavar='URL', action='append',
                       help='Reference (CVE, etc.)')

    parser.add_argument('--list-findings', action='store_true',
                       help='Lister toutes les vulnerabilites')
    parser.add_argument('--generate', action='store_true',
                       help='Generer le rapport')
    parser.add_argument('--format', choices=['markdown', 'html', 'both'],
                       default='markdown',
                       help='Format du rapport (default: markdown)')
    parser.add_argument('--dir', default='reports',
                       help='Repertoire des rapports (default: reports)')

    args = parser.parse_args()

    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(0)

    generator = ReportGenerator(args.dir)

    if args.init:
        generator.init_report(
            name=args.init,
            client=args.client or "",
            tester=args.tester or "",
            scope=args.scope or "",
            methodology=args.methodology
        )

    if args.add_finding:
        if not args.title or not args.severity:
            print("[!] --title et --severity sont requis pour --add-finding")
            sys.exit(1)

        generator.add_finding(
            title=args.title,
            severity=args.severity,
            description=args.description,
            impact=args.impact,
            remediation=args.remediation,
            cvss=args.cvss or "",
            affected_systems=args.affected or [],
            poc=args.poc,
            references=args.reference or []
        )

    if args.list_findings:
        generator.list_findings()

    if args.generate:
        if args.format in ['markdown', 'both']:
            generator.generate_markdown()
        if args.format in ['html', 'both']:
            generator.generate_html()


if __name__ == "__main__":
    main()
