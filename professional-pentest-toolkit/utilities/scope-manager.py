#!/usr/bin/env python3
"""
Scope Manager - Never test out of scope!

This is super important for professional pentesting - you NEVER want to
accidentally test a system that's not authorized. That's how you end up
in legal trouble.

What it does:
- Load scope from a file (IPs, networks, domains, URLs)
- Check if a target is in scope before testing
- Log all scope checks (CYA - Cover Your Ass)
- Prevent out-of-scope testing

Usage:
    python scope-manager.py --load scope.txt
    python scope-manager.py --check 192.168.1.100
    python scope-manager.py --list

NOTE: Always get written authorization before ANY pentest!
"""

import argparse
import ipaddress
import json
import sys
from datetime import datetime
from pathlib import Path
from typing import List, Set, Union
from urllib.parse import urlparse


class ScopeManager:
    """
    Scope manager for penetration testing engagements

    Keeps track of what's in scope and what's not.
    Super critical - never test anything not explicitly authorized!
    """

    def __init__(self, scope_file: str = "scope.json"):
        self.scope_file = Path(scope_file)
        self.ip_ranges: List[ipaddress.IPv4Network] = []  # IP ranges/networks in scope
        self.domains: Set[str] = set()                     # Domains in scope
        self.urls: Set[str] = set()                        # Specific URLs in scope
        self.excluded: Set[str] = set()                    # Explicitly excluded (important!)
        self.engagement_name: str = ""
        self.client_name: str = ""
        self.start_date: str = ""
        self.end_date: str = ""

        # Load existing scope if file exists
        if self.scope_file.exists():
            self.load_from_json()

    def load_from_file(self, filepath: str) -> None:
        """
        Load scope from a text file

        File format:
        - One entry per line
        - IP addresses: 192.168.1.100
        - Networks: 192.168.1.0/24
        - Domains: example.com
        - URLs: https://app.example.com
        - Exclusions: EXCLUDE:192.168.1.5
        - Comments: # This is a comment
        """
        path = Path(filepath)
        if not path.exists():
            print(f"Error: File {filepath} not found")
            sys.exit(1)

        print(f"[*] Loading scope from {filepath}")

        with open(path, 'r') as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith('#'):
                    continue

                if line.startswith('EXCLUDE:'):
                    target = line.replace('EXCLUDE:', '').strip()
                    self.excluded.add(target)
                    print(f"  [-] Exclusion: {target}")
                elif line.startswith('http://') or line.startswith('https://'):
                    self.urls.add(line)
                    domain = urlparse(line).netloc
                    self.domains.add(domain)
                    print(f"  [+] URL: {line}")
                elif '/' in line:
                    try:
                        network = ipaddress.ip_network(line, strict=False)
                        self.ip_ranges.append(network)
                        print(f"  [+] Reseau: {network}")
                    except ValueError:
                        print(f"  [!] Reseau invalide ignore: {line}")
                elif '.' in line and not ' ' in line:
                    if self._is_ip(line):
                        network = ipaddress.ip_network(f"{line}/32", strict=False)
                        self.ip_ranges.append(network)
                        print(f"  [+] IP: {line}")
                    else:
                        self.domains.add(line)
                        print(f"  [+] Domaine: {line}")

        print(f"\n[+] Scope charge: {len(self.ip_ranges)} reseaux, {len(self.domains)} domaines, {len(self.excluded)} exclusions")
        self.save_to_json()

    def _is_ip(self, value: str) -> bool:
        """Verifie si une string est une IP valide"""
        try:
            ipaddress.ip_address(value)
            return True
        except ValueError:
            return False

    def check_target(self, target: str) -> bool:
        """
        Check if a target is in scope

        This is THE critical function - always use this before testing anything!
        Returns True if authorized, False if not.
        """
        # Check exclusions FIRST - these override everything
        if target in self.excluded:
            print(f"[!] DENIED: {target} is EXPLICITLY EXCLUDED from scope")
            self._log_check(target, False, "Explicit exclusion")
            return False

        # Check exact URLs
        if target in self.urls:
            print(f"[+] AUTHORIZED: {target} is in scope (exact URL match)")
            self._log_check(target, True, "Exact URL")
            return True

        # Check domains (including subdomains)
        for domain in self.domains:
            if target == domain or target.endswith(f".{domain}"):
                print(f"[+] AUTHORIZED: {target} matches domain {domain}")
                self._log_check(target, True, f"Domain: {domain}")
                return True

        # Check IP addresses/networks
        if self._is_ip(target):
            ip = ipaddress.ip_address(target)
            for network in self.ip_ranges:
                if ip in network:
                    print(f"[+] AUTHORIZED: {target} is in network {network}")
                    self._log_check(target, True, f"Network: {network}")
                    return True

        # If it's a URL, extract domain and check again
        if target.startswith('http://') or target.startswith('https://'):
            parsed = urlparse(target)
            return self.check_target(parsed.netloc)

        # Not found in any authorized list - DENY
        print(f"[!] DENIED: {target} is NOT in scope")
        self._log_check(target, False, "Out of scope")
        return False

    def _log_check(self, target: str, authorized: bool, reason: str) -> None:
        """
        Log all scope checks

        This creates an audit trail - if client ever questions whether you
        tested something, you have proof of what you checked.
        """
        log_file = Path("scope-checks.log")
        timestamp = datetime.now().isoformat()
        status = "AUTHORIZED" if authorized else "DENIED"

        log_entry = f"{timestamp} | {status} | {target} | {reason}\n"

        with open(log_file, 'a') as f:
            f.write(log_entry)

    def list_scope(self) -> None:
        """Affiche le scope complet"""
        print("\n=== SCOPE D'ENGAGEMENT ===")

        if self.engagement_name:
            print(f"\nEngagement: {self.engagement_name}")
        if self.client_name:
            print(f"Client: {self.client_name}")
        if self.start_date and self.end_date:
            print(f"Periode: {self.start_date} - {self.end_date}")

        if self.ip_ranges:
            print(f"\nReseaux IP autorises ({len(self.ip_ranges)}):")
            for network in self.ip_ranges:
                print(f"  - {network}")

        if self.domains:
            print(f"\nDomaines autorises ({len(self.domains)}):")
            for domain in sorted(self.domains):
                print(f"  - {domain}")

        if self.urls:
            print(f"\nURLs autorisees ({len(self.urls)}):")
            for url in sorted(self.urls):
                print(f"  - {url}")

        if self.excluded:
            print(f"\nExclusions ({len(self.excluded)}):")
            for excl in sorted(self.excluded):
                print(f"  - {excl}")

        print("\n" + "="*50)

    def save_to_json(self) -> None:
        """Sauvegarde le scope en JSON"""
        data = {
            "engagement_name": self.engagement_name,
            "client_name": self.client_name,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "ip_ranges": [str(net) for net in self.ip_ranges],
            "domains": list(self.domains),
            "urls": list(self.urls),
            "excluded": list(self.excluded)
        }

        with open(self.scope_file, 'w') as f:
            json.dump(data, f, indent=2)

        print(f"[+] Scope sauvegarde dans {self.scope_file}")

    def load_from_json(self) -> None:
        """Charge le scope depuis JSON"""
        with open(self.scope_file, 'r') as f:
            data = json.load(f)

        self.engagement_name = data.get("engagement_name", "")
        self.client_name = data.get("client_name", "")
        self.start_date = data.get("start_date", "")
        self.end_date = data.get("end_date", "")

        self.ip_ranges = [ipaddress.ip_network(net) for net in data.get("ip_ranges", [])]
        self.domains = set(data.get("domains", []))
        self.urls = set(data.get("urls", []))
        self.excluded = set(data.get("excluded", []))

        print(f"[+] Scope charge depuis {self.scope_file}")

    def add_metadata(self, engagement: str = None, client: str = None,
                     start: str = None, end: str = None) -> None:
        """Ajoute des metadonnees a l'engagement"""
        if engagement:
            self.engagement_name = engagement
        if client:
            self.client_name = client
        if start:
            self.start_date = start
        if end:
            self.end_date = end

        self.save_to_json()


def main():
    parser = argparse.ArgumentParser(
        description="Gestionnaire de scope pour engagements de pentest",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Exemples:
  # Charger un scope depuis un fichier
  python scope-manager.py --load scope.txt

  # Verifier une cible
  python scope-manager.py --check 192.168.1.100
  python scope-manager.py --check www.example.com

  # Lister le scope
  python scope-manager.py --list

  # Ajouter des metadonnees
  python scope-manager.py --metadata --engagement "Client-2024-001" --client "ACME Corp"

Format du fichier scope.txt:
  192.168.1.0/24
  10.0.0.10
  example.com
  *.example.com
  https://app.example.com
  EXCLUDE:192.168.1.5
  EXCLUDE:admin.example.com
        """
    )

    parser.add_argument('--load', '-l', metavar='FILE',
                       help='Charger le scope depuis un fichier')
    parser.add_argument('--check', '-c', metavar='TARGET',
                       help='Verifier si une cible est dans le scope')
    parser.add_argument('--list', action='store_true',
                       help='Afficher le scope complet')
    parser.add_argument('--metadata', action='store_true',
                       help='Ajouter des metadonnees')
    parser.add_argument('--engagement', metavar='NAME',
                       help='Nom de l\'engagement')
    parser.add_argument('--client', metavar='NAME',
                       help='Nom du client')
    parser.add_argument('--start-date', metavar='DATE',
                       help='Date de debut (YYYY-MM-DD)')
    parser.add_argument('--end-date', metavar='DATE',
                       help='Date de fin (YYYY-MM-DD)')
    parser.add_argument('--scope-file', default='scope.json',
                       help='Fichier JSON du scope (default: scope.json)')

    args = parser.parse_args()

    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(0)

    manager = ScopeManager(args.scope_file)

    if args.load:
        manager.load_from_file(args.load)

    if args.metadata:
        manager.add_metadata(
            engagement=args.engagement,
            client=args.client,
            start=args.start_date,
            end=args.end_date
        )
        print("[+] Metadonnees mises a jour")

    if args.check:
        result = manager.check_target(args.check)
        sys.exit(0 if result else 1)

    if args.list:
        manager.list_scope()


if __name__ == "__main__":
    main()
